两种方式对比：
Runnable:
    1.避免了单继承
    2.适合多个线程处理同一资源的情况，较好的体现了面向对象的思想
    3.编程稍微复杂
Thread:
    1.不能继承其他类
    2.编程简单


线程生命周期
新建-----new Thread()创建了对象
就绪-----线程对象调用start方法
运行-----线程获得CPU，开始执行run方法的线程体
阻塞-----slepp,IO阻塞，等待同步锁，等待通知，suspend(被阻塞的线程在合适的时机会变成就绪状态,调用yield方法会让线程从运行状态变为就绪状态)
死亡-----run方法执行完成，线程抛出异常，直接调用stop方法(容易死锁，不建议)


sleep和yield方法区别：
1.sleep暂停当前线程之后，会给其他线程执行机会，不会理会其他线程的优先级，yield只会给优先级相同或者更高的就绪状态的线程执行
2.sleep会将线程转入阻塞状态，直到阻塞时间到才会转入就绪状态，yield不会将线程转入阻塞状态，是强制让当前线程变为就绪状态
因为完全有可能某个线程调用yield方法，然后立即获得处理器资源执行
3.sleep抛出了interrupted异常，而yield方法没有抛出任何异常
4.sleep比yield方法有更好的可移植性，通常不要用yield控制并发线程的执行

两个线程相互等待对方释放同步锁的时候，会发生死锁

wait,notify,notifyAll方法必须由同步监视器对象调用，分为两种情况
1.在同步方法中，可以直接调用
2.在同步代码块中，用括号中的对象调用这三个方法






